from flask import Flask, jsonify, request, render_template_string
import serial
import time
import re 

app = Flask(__name__)

# --- UART STM32 ---
try:
    ser = serial.Serial("/dev/ttyAMA0", 115200, timeout=1)
    print("Port série /dev/ttyAMA0 ouvert avec succès.")
except serial.SerialException as e:
    print(f"ERREUR FATALE: Impossible d'ouvrir le port série /dev/ttyAMA0. L'application ne peut pas fonctionner. Détails: {e}")
    ser = None

# --- Buffers mémoire ---
temperatures = []
pressures = []
scales = {}

# --- Lecture STM32 et Parsing (inchangé) ---
def read_stm32(cmd: str):
    """Extrait la valeur numérique du format de réponse du STM32."""
    if not ser:
        raise IOError("Le port série n'est pas disponible.")
        
    ser.reset_input_buffer()
    command = f"GET_{cmd}\n".encode()
    ser.write(command)
    time.sleep(0.05)
    raw_resp = ser.read_all().decode().strip()
    
    match = re.search(r"Valeur de [TP]:(\-?\d+\.\d+)", raw_resp)
    
    if match:
        return match.group(1).strip()
    else:
        print(f"Erreur de parsing: Commande envoyée: '{command.decode().strip()}', Réponse brute non reconnue: '{raw_resp}'")
        return None

# --- HTML page avec les nouveaux champs DELETE ---
HTML_PAGE = """
<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>STM32 Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        pre { background: #f4f4f4; padding: 15px; border: 1px solid #ccc; white-space: pre-wrap; border-radius: 5px; }
        h1, h2 { color: #0056b3; }
        button, input[type="number"], label { padding: 10px 15px; margin: 5px 5px 5px 0; border-radius: 5px; }
        button { cursor: pointer; background: #007bff; color: white; border: none; transition: background 0.3s; }
        button:hover { background: #0056b3; }
        .delete-btn { background: #dc3545; }
        .delete-btn:hover { background: #c82333; }
        #output { margin-top: 20px; border-top: 2px solid #0056b3; padding-top: 15px; }
    </style>
</head>
<body>
    <h1>STM32 Dashboard</h1>
    
    <div id="output">
        <h3>Résultats du Serveur</h3>
        <p>Cliquez sur un bouton pour voir la réponse JSON ici.</p>
    </div>
    <hr>
    
    <h2>Température</h2>
    <button onclick="fetchData('/temp', 'POST')">1. Récupérer & Stocker (POST)</button>
    <button onclick="fetchData('/temp', 'GET')">2. Afficher Toutes les Températures (GET)</button>
    <br>
    <label for="temp-index">Index à supprimer:</label>
    <input type="number" id="temp-index" placeholder="Index (0, 1, 2, ...)" value="0" style="width: 150px;">
    <button class="delete-btn" onclick="deleteData('temp')">3. Supprimer Température (DELETE)</button>
    
    <hr>

    <h2>Pression</h2>
    <button onclick="fetchData('/pres', 'POST')">1. Récupérer & Stocker (POST)</button>
    <button onclick="fetchData('/pres', 'GET')">2. Afficher Toutes les Pressions (GET)</button>
    <br>
    <label for="pres-index">Index à supprimer:</label>
    <input type="number" id="pres-index" placeholder="Index (0, 1, 2, ...)" value="0" style="width: 150px;">
    <button class="delete-btn" onclick="deleteData('pres')">3. Supprimer Pression (DELETE)</button>
    
    <hr>
    
    <h2>Échelle (Scale)</h2>
    <button onclick="fetchData('/scale', 'GET')">Afficher Échelles Stockées (GET)</button>
    <button onclick="setScale(0, 1.5)">Définir Échelle [0] à K=1.5 (POST)</button>
    
    <h2>Angle (Calculé)</h2>
    <button onclick="fetchData('/angle', 'GET')">Calculer et Afficher Angles (GET)</button>

    <script>
        const outputDiv = document.getElementById('output');

        function displayData(data) {
            outputDiv.innerHTML = '<h3>Dernière Réponse du Serveur:</h3>' +
                                  '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
        }

        function fetchData(url, method) {
            outputDiv.innerHTML = '<h3>Chargement...</h3>';
            fetch(url, { method: method })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => Promise.reject(data)); 
                }
                return response.json();
            })
            .then(data => displayData(data))
            .catch(error => {
                const errorData = typeof error === 'object' && error !== null ? JSON.stringify(error, null, 2) : error;
                outputDiv.innerHTML = '<h3>Erreur de Requête:</h3><pre>' + errorData + '</pre>';
            });
        }
        
        // Nouvelle fonction pour gérer la suppression (DELETE)
        function deleteData(type) {
            const inputId = type + '-index';
            const index = document.getElementById(inputId).value;
            
            if (index === "" || isNaN(parseInt(index))) {
                alert("Veuillez entrer un index numérique valide.");
                return;
            }
            
            const url = '/' + type + '/' + index; // Ex: /temp/0 ou /pres/1
            
            outputDiv.innerHTML = '<h3>Suppression en cours...</h3>';
            fetch(url, { method: 'DELETE' })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => Promise.reject(data));
                }
                return response.json();
            })
            .then(data => {
                displayData(data);
                alert(`Index ${index} de ${type} supprimé avec succès.`);
            })
            .catch(error => {
                const errorData = typeof error === 'object' && error !== null ? JSON.stringify(error, null, 2) : error;
                outputDiv.innerHTML = '<h3>Erreur de Suppression:</h3><pre>' + errorData + '</pre>';
                alert(`Échec de la suppression: Index ${index} introuvable ou erreur serveur.`);
            });
        }

        function setScale(index, value) {
            const url = '/scale/' + index;
            const data = { "K": value };
            outputDiv.innerHTML = '<h3>Chargement...</h3>';
            fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(data => displayData(data))
            .catch(error => {
                const errorData = typeof error === 'object' && error !== null ? JSON.stringify(error, null, 2) : error;
                outputDiv.innerHTML = '<h3>Erreur:</h3><pre>' + errorData + '</pre>';
            });
        }
    </script>
</body>
</html>
"""

@app.route("/")
def index():
    return render_template_string(HTML_PAGE)

# --- Les routes Flask restent inchangées et utilisent read_stm32 avec parsing ---

@app.route("/temp", methods=["POST", "GET"])
def temp_all():
    global temperatures
    if request.method == "POST":
        try:
            value = read_stm32("T")
        except IOError as e:
            return jsonify({"error": str(e)}), 500
        if value is None:
            return jsonify({"error": "No valid response from STM32 or parsing failed"}), 500
        try:
            float_value = float(value)
            temperatures.append(float_value)
            return jsonify({"message": "Temperature stored", "temperature": float_value})
        except ValueError:
            return jsonify({"error": f"Internal error: could not convert '{value}' to float"}), 500
    return jsonify({"temperatures": temperatures})

@app.route("/temp/<int:x>", methods=["GET", "DELETE"])
def temp_one(x):
    global temperatures
    if request.method == "GET":
        if x < 0 or x >= len(temperatures):
            return jsonify({"error": "Index out of range"}), 404
        return jsonify({"temperature": temperatures[x]})
    elif request.method == "DELETE":
        if x < 0 or x >= len(temperatures):
            return jsonify({"error": "Index out of range"}), 404
        removed = temperatures.pop(x)
        return jsonify({"message": "Deleted", "temperature": removed})

@app.route("/pres", methods=["POST", "GET"])
def pres_all():
    global pressures
    if request.method == "POST":
        try:
            value = read_stm32("P")
        except IOError as e:
            return jsonify({"error": str(e)}), 500
        if value is None:
            return jsonify({"error": "No valid response from STM32 or parsing failed"}), 500
        try:
            float_value = float(value)
            pressures.append(float_value)
            return jsonify({"message": "Pressure stored", "pressure": float_value})
        except ValueError:
            return jsonify({"error": f"Internal error: could not convert '{value}' to float"}), 500
    return jsonify({"pressures": pressures})

@app.route("/pres/<int:x>", methods=["GET", "DELETE"])
def pres_one(x):
    global pressures
    if request.method == "GET":
        if x < 0 or x >= len(pressures):
            return jsonify({"error": "Index out of range"}), 404
        return jsonify({"pressure": pressures[x]})
    elif request.method == "DELETE":
        if x < 0 or x >= len(pressures):
            return jsonify({"error": "Index out of range"}), 404
        removed = pressures.pop(x)
        return jsonify({"message": "Deleted", "pressure": removed})

@app.route("/scale", methods=["GET"])
def get_scales():
    return jsonify(scales)

@app.route("/scale/<int:x>", methods=["POST"])
def set_scale(x):
    data = request.json
    if not data or "K" not in data:
        return jsonify({"error": "Missing K value in JSON body"}), 400
    try:
        k_value = float(data["K"])
        scales[str(x)] = k_value 
        return jsonify({"message": "Scale updated", "scale": {str(x): k_value}})
    except ValueError:
        return jsonify({"error": "K value must be a number"}), 400

@app.route("/angle", methods=["GET"])
def angle():
    result = []
    for i, t in enumerate(temperatures):
        k = scales.get(str(i), 1.0) 
        try:
             k = float(k)
        except ValueError:
             k = 1.0
             
        result.append({"index": i, "temperature": t, "scale": k, "angle": t * k})
        
    return jsonify(result)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)